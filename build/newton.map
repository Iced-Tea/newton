{"version":3,"sources":["webpack/bootstrap 012031a40469a9caaff7","./index.js","./lib/vector.js","./lib/constraint.js","./lib/force.js","./lib/frame.js","./lib/renderers/gl-renderer/gl-util.js","./lib/accumulator.js","./lib/body.js","./lib/constraints/box-constraint.js","./lib/constraints/distance-constraint.js","./lib/constraints/pin-constraint.js","./lib/constraints/rope-constraint.js","./lib/forces/linear-force.js","./lib/particle.js","./lib/renderer.js","./lib/renderers/gl-renderer/index.js","./lib/renderers/gl-renderer/point-renderer.js","./lib/simulator.js","./~/eventemitter2/lib/eventemitter2.js"],"names":[],"mappings":";;;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA,wC;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACbA,eAAc;;AAEd;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;AAGA;;;AAGA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;ACvQA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACVA;;AAEA;;AAEA;AACA;;AAEA;;;;;;;;;;ACPA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2DAA0D;AAC1D;AACA;;AAEA,oBAAmB,qDAAqD;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,kCAAkC,EAAE;AACxE;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;AC9CA;AACA,0BAAyB;AACzB,4BAA2B;AAC3B,yBAAwB;;AAExB,iBAAgB;AAChB,2DAA0D;AAC1D,+CAA8C;;AAE9C,wCAAuC;AACvC,gCAA+B;AAC/B,KAAI;AACJ;;AAEA;AACA,4BAA2B;AAC3B,8BAA6B;;AAE7B,iBAAgB;AAChB,uDAAsD;AACtD,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;AC9HA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC5BA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAiB,2BAA2B;AAC5C;AACA;AACA;;AAEA;;;;;;;;;;ACtBA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,kBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;;;;;;;;;;ACvBA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACvCA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;AClBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;AC3CA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;AChBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AC/CA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;ACRA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClCA;;AAEA;;AAEA;AACA,0BAAyB;AACzB,4BAA2B;AAC3B,yBAAwB;;AAExB,iBAAgB;AAChB,2DAA0D;AAC1D,+CAA8C;;AAE9C,wCAAuC;AACvC,gCAA+B;AAC/B,KAAI;AACJ;;AAEA;AACA,4BAA2B;AAC3B,8BAA6B;;AAE7B,iBAAgB;AAChB,uDAAsD;AACtD,KAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;ACzIA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAiB,sBAAsB;AACvC,oBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;AC5FA,oCAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,qDAAoD,YAAY;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;AACb;AACA;AACA,mDAAkD,uBAAuB;AACzE;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,sCAAqC,WAAW;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,uCAAsC,cAAc;AACpD;;AAEA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;AAC5B,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,OAAO;;AAE5B;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAkB,oBAAoB;AACtC;;AAEA,sBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;;AAEA,kDAAiD,YAAY;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA,EAAC","sourcesContent":["\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","module.exports = {\n  Simulator: require('./lib/simulator'),\n  GLRenderer: require('./lib/renderers/gl-renderer'),\n  Particle: require('./lib/particle'),\n  Vector: require('./lib/vector'),\n  Body: require('./lib/body'),\n  Constraint: require('./lib/constraint'),\n  PinConstraint: require('./lib/constraints/pin-constraint'),\n  DistanceConstraint: require('./lib/constraints/distance-constraint'),\n  RopeConstraint: require('./lib/constraints/rope-constraint'),\n  BoxConstraint: require('./lib/constraints/box-constraint'),\n  Force: require('./lib/force'),\n  LinearForce: require('./lib/forces/linear-force')\n};\n","var pool = [];  // Vector object pooling (avoid GC)\n\nfunction Vector(x, y) {\n  if (!(this instanceof Vector)) return new Vector(x, y);\n  this.x = x;\n  this.y = y;\n}\n\n\nVector.claim = function() {\n  return pool.pop() || Vector();\n};\n\nVector.getDistance = function(a, b) {\n  var dx = a.x - b.x;\n  var dy = a.y - b.y;\n  return Math.sqrt(dx * dx + dy * dy);\n};\n\nVector.pool = function(size) {\n  if (typeof size !== 'undefined') {\n    pool.length = 0;\n    for (var i = 0; i < size; i++) {\n      pool.push(Vector());\n    }\n  }\n  else {\n    return pool.length;\n  }\n};\n\n\nVector.prototype.add = function(v) {\n  this.x += v.x;\n  this.y += v.y;\n  return this;\n};\n\nVector.prototype.clone = function() {\n  return Vector(this.x, this.y);\n};\n\nVector.prototype.copy = function(v) {\n  this.x = v.x;\n  this.y = v.y;\n  return this;\n};\n\nVector.prototype.pool = function() {\n  return Vector.claim().copy(this);\n};\n\nVector.prototype.free = function() {\n  pool.push(this);\n  return this;\n};\n\nVector.prototype.getLength = function() {\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\nVector.prototype.min = function(v) {\n  if (this.x < v.x) this.x = v.x;\n  if (this.y < v.y) this.y = v.y;\n  return this;\n};\n\nVector.prototype.max = function(v) {\n  if (this.x > v.x) this.x = v.x;\n  if (this.y > v.y) this.y = v.y;\n  return this;\n};\n\nVector.prototype.rotate = function(angle) {\n  var x = this.x;\n  var y = -this.y;\n  var sin = Math.sin(angle);\n  var cos = Math.cos(angle);\n  this.x = x * cos - y * sin;\n  this.y = -(x * sin + y * cos);\n  return this;\n};\n\nVector.prototype.scale = function(scalar) {\n  this.x *= scalar;\n  this.y *= scalar;\n  return this;\n};\n\nVector.prototype.sub = function(v) {\n  this.x -= v.x;\n  this.y -= v.y;\n  return this;\n};\n\nVector.prototype.zero = function() {\n  this.x = this.y = 0;\n  return this;\n};\n\n\nmodule.exports = Vector;\n\n\n/*\n\n\n// One-off vector for single computes\n\nVector.scratch = new Vector();\n\n// Static methods\n\n// New instances\n\n// Setters\n\nVector.prototype.set = function(x, y) {\n  this.x = x;\n  this.y = y;\n  return this;\n};\n\n// Add\n\nVector.prototype.add = function(v) {\n  this.x += v.x;\n  this.y += v.y;\n  return this;\n};\n\nVector.prototype.addXY = function(x, y) {\n  this.x += x;\n  this.y += y;\n  return this;\n};\n\nVector.prototype.subXY = function(x, y) {\n  this.x -= x;\n  this.y -= y;\n  return this;\n};\n\nVector.prototype.merge = function(v) {\n  var dx = v.x - this.x;\n  var dy = v.y - this.y;\n  if (dx > 0 && this.x >= 0) this.x += dx;\n  else if (dx < 0 && this.x <= 0) this.x += dx;\n  if (dy > 0 && this.y >= 0) this.y += dy;\n  else if (dy < 0 && this.y <= 0) this.y += dy;\n  return this;\n};\n\n// Scale\n\nVector.prototype.mult = function(v) {\n  this.x *= v.x;\n  this.y *= v.y;\n  return this;\n};\n\nVector.prototype.div = function(v) {\n  this.x /= v.x;\n  this.y /= v.y;\n  return this;\n};\n\nVector.prototype.reverse = function() {\n  this.x = -this.x;\n  this.y = -this.y;\n  return this;\n};\n\nVector.prototype.unit = function() {\n  this.scale(1 / this.getLength());\n  return this;\n};\n\n// Rotate\n\nVector.prototype.turnRight = function() {\n  var x = this.x;\n  var y = this.y;\n  this.x = -y;\n  this.y = x;\n  return this;\n};\n\nVector.prototype.turnLeft = function() {\n  var x = this.x;\n  var y = this.y;\n  this.x = y;\n  this.y = -x;\n  return this;\n};\n\nVector.prototype.rotateAbout = function(pivot, angle) {\n  this.sub(pivot).rotateBy(angle).add(pivot);\n  return this;\n};\n\n// Get\n\nVector.prototype.getDot = function(v) {\n  return this.x * v.x + this.y * v.y;\n};\n\nVector.prototype.getCross = function(v) {\n  return this.x * v.y + this.y * v.x;\n};\n\nVector.prototype.getLength = function() {\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\nVector.prototype.getLength2 = function() {\n  // Squared length\n  return this.x * this.x + this.y * this.y;\n};\n\nVector.prototype.getAngle = function() {\n  return Math.atan2(-this.y, this.x);\n};\n\nVector.prototype.getAngleTo = function(v) {\n  // The nearest angle between two vectors\n  // (origin of 0,0 for both)\n  var cos = this.x * v.x + this.y * v.y;\n  var sin = this.y * v.x - this.x * v.y;\n\n  return Math.atan2(sin, cos);\n};\n\n// If projection >= 0, it's in this half plane\n// Otherwise, it isn't\nVector.prototype.getProjection = function(vPoint, vDir) {\n  return this.clone().sub(vPoint).getDot(vDir);\n};\n\nVector.prototype.applyProjection = function(projection, vDir) {\n  this.sub(dir.clone().scale(projection));\n  return this;\n};\n\nVector.prototype.projectOnto = function(vPoint, vDir) {\n  var projection = this.clone().sub(vPoint).getDot(vDir);\n  this.sub(vDir.clone().scale(projection));\n  return this;\n};\n\nVector.prototype.projectSegment = function(vA, vB) {\n  var normal = vB.clone().sub(vA).turnLeft().unit();\n  var projection = this.clone().sub(vA).getDot(normal);\n  this.sub(normal.scale(projection));\n\n  if (this.x > vA.x && this.x > vB.x) this.x = Math.max(vA.x, vB.x);\n  else if (this.x < vA.x && this.x < vB.x) this.x = Math.min(vA.x, vB.x);\n  if (this.y > vA.y && this.y > vB.y) this.y = Math.max(vA.y, vB.y);\n  else if (this.y < vA.y && this.y < vB.y) this.y = Math.min(vA.y, vB.y);\n\n  return this;\n};\n\n*/\n","var id = 0;\n\nfunction Constraint() {\n  this.id = id++;\n}\n\nConstraint.prototype.type = 'Constraint';\nConstraint.prototype.priority = 10;\nConstraint.prototype.correct = function() {};\n\nmodule.exports = Constraint;\n","function Force() {\n\n}\n\nForce.prototype.type = 'Force';\nForce.prototype.apply = function() {};\n\nmodule.exports = Force;\n","module.exports = getFrame();\n\nfunction getFrame() {\n  var lastTime = 0;\n\n  // Browsers\n  if (typeof window !== 'undefined') {\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\n    var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n    var isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+\n    var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;\n    var isChrome = !!window.chrome && !isOpera;\n\n    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n      window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\n      window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\n    }\n\n    if (!window.requestAnimationFrame) {\n      window.requestAnimationFrame = timeoutFrame;\n      window.cancelAnimationFrame = cancelTimeoutFrame;\n    }\n\n    return {\n      onFrame: window.requestAnimationFrame.bind(window),\n      cancelFrame: window.cancelAnimationFrame.bind(window)\n    };\n  }\n\n  // Node\n  return {\n    onFrame: timeoutFrame,\n    cancelFrame: cancelTimeoutFrame\n  };\n\n  function timeoutFrame(simulator, element) {\n    var currTime = new Date().getTime();\n    var timeToCall = Math.max(0, 16 - (currTime - lastTime));\n    var id = setTimeout(function() { simulator(currTime + timeToCall); }, timeToCall);\n    lastTime = currTime + timeToCall;\n    return id;\n  }\n\n  function cancelTimeoutFrame(id) {\n    clearTimeout(id);\n  }\n}\n","var POINT_VS = [\n  'uniform vec2 viewport;',\n  'attribute vec3 position;',\n  'attribute float size;',\n\n  'void main() {',\n    'vec2 scaled = ((position.xy / viewport) * 2.0) - 1.0;',\n    'vec2 flipped = vec2(scaled.x, -scaled.y);',\n\n    'gl_Position = vec4(flipped, 0, 1);',\n    'gl_PointSize = size + 1.0;',\n  '}'\n].join('\\n');\n\nvar CIRCLE_FS = [\n  'precision mediump float;',\n  'uniform sampler2D texture;',\n\n  'void main() {',\n    'gl_FragColor = texture2D(texture, gl_PointCoord);',\n  '}'\n].join('\\n');\n\nmodule.exports = {\n  getGLContext: getGLContext,\n  createCircleTexture: createCircleTexture,\n  createCircleShader: createCircleShader,\n  createShaderProgram: createShaderProgram,\n  createTexture: createTexture\n};\n\nfunction getGLContext(canvas) {\n  var names = [\n    'webgl',\n    'experimental-webgl',\n    'webkit-3d',\n    'moz-webgl'\n  ];\n\n  var i = 0, gl;\n  while (!gl && i++ < names.length) {\n    try {\n      gl = canvas.getContext(names[i]);\n    } catch(e) {}\n  }\n  return gl;\n}\n\nfunction createCircleTexture(gl, size) {\n  size = size || 32;\n\n  var canvas = document.createElement('canvas');\n  canvas.width = canvas.height = size;\n  var ctx = canvas.getContext('2d');\n  var rad = size * 0.5;\n\n  ctx.beginPath();\n  ctx.arc(rad, rad, rad, 0, Math.PI * 2, false);\n  ctx.closePath();\n  ctx.fillStyle = '#fff';\n  ctx.fill();\n\n  return createTexture(gl, canvas);\n}\n\nfunction createTexture(gl, data) {\n  var texture = gl.createTexture();\n\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.generateMipmap(gl.TEXTURE_2D);\n  gl.bindTexture(gl.TEXTURE_2D, null);\n\n  return texture;\n}\n\nfunction createShaderProgram(gl, vsText, fsText) {\n  var vs = gl.createShader(gl.VERTEX_SHADER);\n  var fs = gl.createShader(gl.FRAGMENT_SHADER);\n\n  gl.shaderSource(vs, vsText);\n  gl.shaderSource(fs, fsText);\n\n  gl.compileShader(vs);\n  gl.compileShader(fs);\n\n  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n    console.error('error compiling VS shaders:', gl.getShaderInfoLog(vs));\n    throw new Error('shader failure');\n  }\n\n  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n    console.error('error compiling FS shaders:', gl.getShaderInfoLog(fs));\n    throw new Error('shader failure');\n  }\n\n  var program = gl.createProgram();\n\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n\n  return program;\n}\n\nfunction createCircleShader(gl, viewportArray, viewportAttr, positionAttr, sizeAttr) {\n  viewportAttr = viewportAttr || 'viewport';\n  positionAttr = positionAttr || 'position';\n  sizeAttr = sizeAttr || 'size';\n\n  var shader = createShaderProgram(gl, POINT_VS, CIRCLE_FS);\n  shader.uniforms = {\n    viewport: gl.getUniformLocation(shader, viewportAttr)\n  };\n  shader.attributes = {\n    position: gl.getAttribLocation(shader, positionAttr),\n    size: gl.getAttribLocation(shader, sizeAttr)\n  };\n  gl.useProgram(shader);\n  gl.uniform2fv(shader.uniforms.viewport, viewportArray);\n\n  return shader;\n}\n","function Accumulator(interval, max) {\n  this._interval = interval;\n  this._max = max;\n  this._total = 0;\n  this._lastTime = 0;\n  this._startTime = Date.now();\n}\n\nAccumulator.prototype.freeze = function() {\n  this._time = Date.now();\n  this._buffer = this._time - this._lastTime;\n  this._lastTime = this._time;\n\n  return this._interval;\n};\n\nAccumulator.prototype.next = function() {\n  if (this._buffer > this._max) {\n    this._buffer = 0;\n    return false;\n  }\n  if (this._buffer < this._interval) return false;\n\n  this._total += this._interval;\n  this._buffer -= this._interval;\n  return this._total;\n};\n\nmodule.exports = Accumulator;\n","function Body() {\n  if (!(this instanceof Body)) return new Body();\n\n  this._entities = [];\n  this._sim = undefined;\n}\n\nBody.prototype.type = 'Body';\n\nBody.prototype.add = function(entity) {\n  this._entities.push(entity);\n  if (this._sim) this._sim.add(entity);\n  return entity;\n};\n\nBody.prototype.setSimulator = function(sim) {\n  this._sim = sim;\n  for (var i = 0; i < this._entities.length; i++) {\n    sim.add(this._entities[i]);\n  }\n};\n\nmodule.exports = Body;\n","'use strict';\n\nvar Constraint = require('../constraint');\nvar Vector = require('../vector');\n\nfunction BoxConstraint(x, y, width, height) {\n  if (!(this instanceof BoxConstraint)) return new BoxConstraint(x, y, width, height);\n  Constraint.call(this);\n\n  this._min = Vector(x, y);\n  this._max = Vector(x + width, y + height);\n}\n\nBoxConstraint.prototype = Object.create(Constraint.prototype);\n\nBoxConstraint.prototype.priority = 0;\n\nBoxConstraint.prototype.correct = function(time, particles) {\n  for (var i = 0; i < particles.length; i++) {\n    particles[i].bound(this._min, this._max);\n  }\n};\n\nmodule.exports = BoxConstraint;\n","// TODO: make ordering smarter. detect chains\n\nvar Vector = require('../vector');\nvar Constraint = require('../constraint');\n\nfunction DistanceConstraint(p1, p2) {\n  if (!(this instanceof DistanceConstraint)) return new DistanceConstraint(p1, p2);\n  Constraint.call(this);\n\n  this._p1 = p1;\n  this._p2 = p2;\n  this._distance = this.getDistance();\n  this._stiffness = 1;\n}\n\nDistanceConstraint.prototype = Object.create(Constraint.prototype);\n\nDistanceConstraint.prototype.getDistance = function() {\n  return Vector.getDistance(this._p1.position, this._p2.position);\n};\n\nDistanceConstraint.prototype.correct = function(time, particles) {\n  var pos1 = this._p1.position;\n  var pos2 = this._p2.position;\n  var delta = pos2.pool().sub(pos1);\n  var length = delta.getLength();\n  var offBy = length - this._distance;\n  // TODO: handle different masses\n  var factor = offBy / length * this._stiffness;\n  var correction1 = delta.pool().scale(factor * 1);\n  var correction2 = delta.scale(-factor * 1);\n\n  this._p1.correct(correction1);\n  this._p2.correct(correction2);\n\n  delta.free();\n  correction1.free();\n};\n\nmodule.exports = DistanceConstraint;\n","var Constraint = require('../constraint');\n\nfunction PinConstraint(particle) {\n  if (!(this instanceof PinConstraint)) return new PinConstraint(particle);\n  Constraint.call(this);\n\n  this._particle = particle;\n  this._position = particle.position.clone();\n}\n\nPinConstraint.prototype = Object.create(Constraint.prototype);\n\nPinConstraint.prototype.priority = 0;\n\nPinConstraint.prototype.correct = function(time, particles) {\n  this._particle.place(this._position);\n};\n\nmodule.exports = PinConstraint;\n","// TODO: make ordering smarter. detect chains\n// TODO: inherit from distanceconstraint, or just give distanceconstraint some options\n\nvar Vector = require('../vector');\nvar Constraint = require('../constraint');\n\nfunction RopeConstraint(p1, p2) {\n  if (!(this instanceof RopeConstraint)) return new RopeConstraint(p1, p2);\n  Constraint.call(this);\n\n  this._p1 = p1;\n  this._p2 = p2;\n  this._distance = this.getDistance();\n  this._stiffness = 1;\n}\n\nRopeConstraint.prototype = Object.create(Constraint.prototype);\n\nRopeConstraint.prototype.getDistance = function() {\n  return Vector.getDistance(this._p1.position, this._p2.position);\n};\n\nRopeConstraint.prototype.correct = function(time, particles) {\n  var pos1 = this._p1.position;\n  var pos2 = this._p2.position;\n  var delta = pos2.pool().sub(pos1);\n  var length = delta.getLength();\n  var offBy = length - this._distance;\n\n  if (offBy <= 0) return;\n\n  // TODO: handle different masses\n  var factor = offBy / length * this._stiffness;\n  var correction1 = delta.pool().scale(factor * 1);\n  var correction2 = delta.scale(-factor * 1);\n\n  this._p1.correct(correction1);\n  this._p2.correct(correction2);\n\n  delta.free();\n  correction1.free();\n};\n\nmodule.exports = RopeConstraint;\n","var Force = require('../force');\nvar Vector = require('../vector');\n\nfunction LinearForce(strength, angle) {\n  if (!(this instanceof LinearForce)) return new LinearForce(strength, angle);\n  Force.call(this);\n\n  this._vector = Vector(strength, 0).rotate(angle);\n}\n\nLinearForce.prototype = Object.create(Force.prototype);\n\nLinearForce.prototype.applyTo = function(particle) {\n  particle.accelerate(this._vector);\n};\n\nmodule.exports = LinearForce;\n","var Vector = require('./vector');\n\nfunction Particle(x, y, size) {\n  if (!(this instanceof Particle)) return new Particle(x, y, size);\n  this.position = Vector(x, y);\n  this.lastPosition = Vector(x, y);\n  this.acceleration = Vector(0, 0);\n  this._velocityBuffer = Vector(0, 0);\n}\n\nParticle.prototype.type = 'Particle';\n\nParticle.prototype.accelerate = function(v) {\n  this.acceleration.add(v);\n};\n\nParticle.prototype.bound = function(min, max) {\n  this.position.min(min).max(max);\n};\n\nParticle.prototype.correct = function(v) {\n  this.position.add(v);\n};\n\nParticle.prototype.integrate = function(time) {\n  this._velocityBuffer\n    .copy(this.position)\n    .sub(this.lastPosition);\n\n  this.acceleration\n    .scale(time * time);\n\n  this.lastPosition.copy(this.position);\n\n  this.position\n    .add(this._velocityBuffer)\n    .add(this.acceleration);\n\n  this.acceleration.zero();\n};\n\nParticle.prototype.place = function(v) {\n  this.position.copy(v);\n  this.lastPosition.copy(this.position);\n  return this;\n};\n\nmodule.exports = Particle;\n","function Renderer() {\n\n}\n\nRenderer.prototype.render = function(sim) {\n  this._sim = sim;\n};\n\nmodule.exports = Renderer;\n","var Renderer = require('../../renderer');\nvar GLUtil = require('./gl-util');\nvar onFrame = require('../../frame').onFrame;\nvar PointRenderer = require('./point-renderer');\n\nvar MAX_PARTICLES = 10000;\n\nfunction GLRenderer(el) {\n  if (!(this instanceof GLRenderer)) return new GLRenderer(el);\n\n  this._drawFrame = this._drawFrame.bind(this);\n  this._gl = GLUtil.getGLContext(el);\n  this._viewportArray = new Float32Array([el.width, el.height]);\n  this._pointRenderer = new PointRenderer(this._gl, this._viewportArray);\n}\n\nGLRenderer.prototype = Object.create(Renderer.prototype);\n\nGLRenderer.prototype.render = function(sim) {\n  this._sim = sim;\n  onFrame(this._drawFrame);\n};\n\nGLRenderer.prototype._drawFrame = function() {\n  this._clear();\n  this._pointRenderer.draw(this._sim.getParticles());\n  onFrame(this._drawFrame);\n};\n\nGLRenderer.prototype._clear = function() {\n  var gl = this._gl;\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n};\n\nmodule.exports = GLRenderer;\n\n","var GLUtil = require('./gl-util');\n\nvar MAX_POINTS = 10000;\n\nvar VERTEX_SHADER = [\n  'uniform vec2 viewport;',\n  'attribute vec3 position;',\n  'attribute float size;',\n\n  'void main() {',\n    'vec2 scaled = ((position.xy / viewport) * 2.0) - 1.0;',\n    'vec2 flipped = vec2(scaled.x, -scaled.y);',\n\n    'gl_Position = vec4(flipped, 0, 1);',\n    'gl_PointSize = size + 1.0;',\n  '}'\n].join('\\n');\n\nvar FRAGMENT_SHADER = [\n  'precision mediump float;',\n  'uniform sampler2D texture;',\n\n  'void main() {',\n    'gl_FragColor = texture2D(texture, gl_PointCoord);',\n  '}'\n].join('\\n');\n\nfunction PointRenderer(gl, viewportArray) {\n  this._gl = gl;\n  this._viewportArray = viewportArray;\n  this._verticesCache = [];\n  this._sizesCache = [];\n  this._vArray = new Float32Array(MAX_POINTS * 2);\n  this._sArray = new Float32Array(MAX_POINTS);\n  this._texture = createCircleTexture(gl);\n  this._shader = createCircleShader(gl, viewportArray);\n  this._positionBuffer = gl.createBuffer();\n  this._sizeBuffer = gl.createBuffer();\n}\n\nPointRenderer.prototype.draw = function(points) {\n  var gl = this._gl;\n  var vertices = this._verticesCache;\n  var sizes = this._sizesCache;\n  var vArray = this._vArray;\n  var sArray = this._sArray;\n  var attributes = this._shader.attributes;\n  var point;\n\n  vertices.length = 0;\n  sizes.length = 0;\n\n  for (var i = 0; i < points.length; i++) {\n    point = points[i];\n    vertices.push(point.position.x, point.position.y);\n    sizes.push(4);\n  }\n\n  vArray.set(vertices, 0);\n  sArray.set(sizes, 0);\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(gl.TEXTURE_2D, this._texture);\n\n  // position buffer\n  gl.bindBuffer(gl.ARRAY_BUFFER, this._positionBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, vArray, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(attributes.position, 2, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(attributes.position);\n\n  // size buffer\n  gl.bindBuffer(gl.ARRAY_BUFFER, this._sizeBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, sArray, gl.STATIC_DRAW);\n  gl.vertexAttribPointer(attributes.size, 1, gl.FLOAT, false, 0, 0);\n  gl.enableVertexAttribArray(attributes.size);\n\n  gl.drawArrays(gl.POINTS, 0, vertices.length / 2);\n};\n\nmodule.exports = PointRenderer;\n\nfunction createCircleTexture(gl, size) {\n  size = size || 128;\n\n  var canvas = document.createElement('canvas');\n  canvas.width = canvas.height = size;\n  var ctx = canvas.getContext('2d');\n  var rad = size * 0.5;\n\n  ctx.beginPath();\n  ctx.arc(rad, rad, rad, 0, Math.PI * 2, false);\n  ctx.closePath();\n  ctx.fillStyle = '#fff';\n  ctx.fill();\n\n  return GLUtil.createTexture(gl, canvas);\n}\n\nfunction createCircleShader(gl, viewportArray) {\n  var vs = gl.createShader(gl.VERTEX_SHADER);\n  var fs = gl.createShader(gl.FRAGMENT_SHADER);\n\n  gl.shaderSource(vs, VERTEX_SHADER);\n  gl.shaderSource(fs, FRAGMENT_SHADER);\n\n  gl.compileShader(vs);\n  gl.compileShader(fs);\n\n  if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {\n    console.error('error compiling VS shaders:', gl.getShaderInfoLog(vs));\n    throw new Error('shader failure');\n  }\n\n  if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {\n    console.error('error compiling FS shaders:', gl.getShaderInfoLog(fs));\n    throw new Error('shader failure');\n  }\n\n  var program = gl.createProgram();\n\n  gl.attachShader(program, vs);\n  gl.attachShader(program, fs);\n  gl.linkProgram(program);\n\n  program.uniforms = {\n    viewport: gl.getUniformLocation(program, 'viewport')\n  };\n\n  program.attributes = {\n    position: gl.getAttribLocation(program, 'position'),\n    size: gl.getAttribLocation(program, 'size')\n  };\n\n  gl.useProgram(program);\n  gl.uniform2fv(program.uniforms.viewport, viewportArray);\n\n  return program;\n}\n","var Emitter = require('eventemitter2');\nvar onFrame = require('./frame').onFrame;\nvar Accumulator = require('./accumulator');\n\nfunction Simulator() {\n  if (!(this instanceof Simulator)) return new Simulator();\n\n  Emitter.call(this);\n\n  this._step = this._step.bind(this);\n  this._stepInterval = 1000 / 60;     // TODO: option\n  this._running = false;\n  this._accumulator = undefined;\n  this._particles = [];\n  this._bodies = [];\n  this._forces = [];\n  this._constraints = [];\n  this._iterations = 10;             // TODO: option\n}\n\nSimulator.prototype = Object.create(Emitter.prototype);\n\nSimulator.prototype.start = function() {\n  this._running = true;\n  this._accumulator = new Accumulator(this._stepInterval, 100);\n  onFrame(this._step);\n};\n\nSimulator.prototype.add = function(entity) {\n  if (entity.type === 'Particle') this._particles.push(entity);\n  else if (entity.type === 'Force') this._forces.push(entity);\n  else if (entity.type === 'Constraint') {\n    this._constraints.push(entity);\n    this._constraints.sort(prioritySort);\n  }\n  else if (entity.type === 'Body') {\n    this._bodies.push(entity);\n    entity.setSimulator(this);\n  }\n};\n\nSimulator.prototype.getParticles = function() {\n  return this._particles;\n};\n\nSimulator.prototype._step = function() {\n  if (!this._running) return;\n\n  var time;\n  var interval = this._accumulator.freeze();\n  while (time = this._accumulator.next()) {\n    this._simulate(interval, time);\n  }\n\n  onFrame(this._step);\n};\n\nSimulator.prototype._simulate = function(time, totalTime) {\n  this._integrate(time);\n  this._constrain(time);\n};\n\nSimulator.prototype._integrate = function(time) {\n  var particles = this._particles;\n  var forces = this._forces;\n  var particle, force;\n\n  for (var p = 0; p < particles.length; p++) {\n    particle = particles[p];\n    for (var f = 0; f < forces.length; f++) {\n      force = forces[f];\n      force.applyTo(particle);\n    }\n    particle.integrate(time);\n  }\n};\n\nSimulator.prototype._constrain = function(time) {\n  var constraints = this._constraints;\n  var particles = this._particles;\n\n  for (var i = 0; i < this._iterations; i++) {\n    for (var c = 0; c < constraints.length; c++) {\n      constraints[c].correct(time, particles);\n    }\n  }\n};\n\nmodule.exports = Simulator;\n\nfunction prioritySort(a, b) {\n  return b.priority - a.priority || b.id - a.id;\n}\n",";!function(exports, undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || this._all;\n    }\n    else {\n      return this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return EventEmitter;\n    });\n  } else {\n    exports.EventEmitter2 = EventEmitter;\n  }\n\n}(typeof process !== 'undefined' && typeof process.title !== 'undefined' && typeof exports !== 'undefined' ? exports : window);\n"],"sourceRoot":"webpack-module://"}